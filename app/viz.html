<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.js webgl - gpgpu - water</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
  body {
    background-color: #000000;
    margin: 0px;
    overflow: hidden;
    font-family:Monospace;
    font-size:13px;
    text-align:center;
    text-align:center;
  }

  a {
    color:#0078ff;
  }

  #info {
    color: #ffffff;
    position: absolute;
    top: 10px;
    width: 100%;
    display: none;
  }

  .dg {
    display: none;
  }

  </style>

  <script src="lib/d3.v3.min.js">//http://d3js.org/</script>
  <script src="lib/topojson.v1.min.js"></script>
  <script src="lib/papaparse.js"></script>

  <script src="lib/logarithmic_scaler.js"></script>
</head>
<body>


  <div id="info">
    <a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - <span id="waterSize"></span> webgl gpgpu water<br/>
    Select <span id="options"></span> water size<br/>
    Move mouse to disturb water.<br>
    Press mouse button to orbit around. 'W' key toggles wireframe.
  </div>

  <script src="../build/three.js"></script>
  <script src="js/WebGL.js"></script>
  <script src="js/libs/stats.min.js"></script>
  <script src="js/libs/dat.gui.min.js"></script>
  <script src="js/controls/OrbitControls.js"></script>
  <script src="js/SimplexNoise.js"></script>

  <script src="js/GPUComputationRenderer.js"></script>


  <!-- This is the 'compute shader' for the water heightmap: -->
  <script id="heightmapFragmentShader" type="x-shader/x-fragment">

  #include <common>

  uniform vec2 mousePos;
  uniform float mouseSize;
  uniform float viscosityConstant;
  uniform float heightCompensation;

  void main()	{

    vec2 cellSize = 1.0 / resolution.xy;

    vec2 uv = gl_FragCoord.xy * cellSize;

    // heightmapValue.x == height from previous frame
    // heightmapValue.y == height from penultimate frame
    // heightmapValue.z, heightmapValue.w not used
    vec4 heightmapValue = texture2D( heightmap, uv );

    // Get neighbours
    vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
    vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
    vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
    vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );

    // https://web.archive.org/web/20080618181901/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm

    float newHeight = ( ( north.x + south.x + east.x + west.x ) * 0.5 - heightmapValue.y ) * viscosityConstant;

    // Mouse influence
    float mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );
    newHeight += ( cos( mousePhase ) + 1.0 ) * 0.28;

    heightmapValue.y = heightmapValue.x;
    heightmapValue.x = newHeight;

    gl_FragColor = heightmapValue;

  }

  </script>

  <!-- This is just a smoothing 'compute shader' for using manually: -->
  <script id="smoothFragmentShader" type="x-shader/x-fragment">

  uniform sampler2D texture;

  void main()	{

    vec2 cellSize = 1.0 / resolution.xy;

    vec2 uv = gl_FragCoord.xy * cellSize;

    // Computes the mean of texel and 4 neighbours
    vec4 textureValue = texture2D( texture, uv );
    textureValue += texture2D( texture, uv + vec2( 0.0, cellSize.y ) );
    textureValue += texture2D( texture, uv + vec2( 0.0, - cellSize.y ) );
    textureValue += texture2D( texture, uv + vec2( cellSize.x, 0.0 ) );
    textureValue += texture2D( texture, uv + vec2( - cellSize.x, 0.0 ) );

    textureValue /= 5.0;

    gl_FragColor = textureValue;

  }

  </script>

  <!-- This is a 'compute shader' to read the current level and normal of water at a point -->
  <!-- It is used with a variable of size 1x1 -->
  <script id="readWaterLevelFragmentShader" type="x-shader/x-fragment">

  uniform vec2 point1;

  uniform sampler2D texture;

  // Integer to float conversion from https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target

  float shift_right( float v, float amt ) {

    v = floor( v ) + 0.5;
    return floor( v / exp2( amt ) );

  }

  float shift_left( float v, float amt ) {

    return floor( v * exp2( amt ) + 0.5 );

  }

  float mask_last( float v, float bits ) {

    return mod( v, shift_left( 1.0, bits ) );

  }

  float extract_bits( float num, float from, float to ) {

    from = floor( from + 0.5 ); to = floor( to + 0.5 );
    return mask_last( shift_right( num, from ), to - from );

  }

  vec4 encode_float( float val ) {
    if ( val == 0.0 ) return vec4( 0, 0, 0, 0 );
    float sign = val > 0.0 ? 0.0 : 1.0;
    val = abs( val );
    float exponent = floor( log2( val ) );
    float biased_exponent = exponent + 127.0;
    float fraction = ( ( val / exp2( exponent ) ) - 1.0 ) * 8388608.0;
    float t = biased_exponent / 2.0;
    float last_bit_of_biased_exponent = fract( t ) * 2.0;
    float remaining_bits_of_biased_exponent = floor( t );
    float byte4 = extract_bits( fraction, 0.0, 8.0 ) / 255.0;
    float byte3 = extract_bits( fraction, 8.0, 16.0 ) / 255.0;
    float byte2 = ( last_bit_of_biased_exponent * 128.0 + extract_bits( fraction, 16.0, 23.0 ) ) / 255.0;
    float byte1 = ( sign * 128.0 + remaining_bits_of_biased_exponent ) / 255.0;
    return vec4( byte4, byte3, byte2, byte1 );
  }

  void main()	{

    vec2 cellSize = 1.0 / resolution.xy;

    float waterLevel = texture2D( texture, point1 ).x;

    vec2 normal = vec2(
      ( texture2D( texture, point1 + vec2( - cellSize.x, 0 ) ).x - texture2D( texture, point1 + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
      ( texture2D( texture, point1 + vec2( 0, - cellSize.y ) ).x - texture2D( texture, point1 + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS );

      if ( gl_FragCoord.x < 1.5 ) {

        gl_FragColor = encode_float( waterLevel );

      } else if ( gl_FragCoord.x < 2.5 ) {

        gl_FragColor = encode_float( normal.x );

      } else if ( gl_FragCoord.x < 3.5 ) {

        gl_FragColor = encode_float( normal.y );

      } else {

        gl_FragColor = encode_float( 0.0 );

      }

    }

    </script>

    <!-- This is the water visualization shader, copied from the MeshPhongMaterial and modified: -->
    <script id="waterVertexShader" type="x-shader/x-vertex">

    uniform sampler2D heightmap;

    #define PHONG

    varying vec3 vViewPosition;

    #ifndef FLAT_SHADED

    varying vec3 vNormal;

    #endif

    #include <common>
    #include <uv_pars_vertex>
    #include <uv2_pars_vertex>
    #include <displacementmap_pars_vertex>
    #include <envmap_pars_vertex>
    #include <color_pars_vertex>
    #include <morphtarget_pars_vertex>
    #include <skinning_pars_vertex>
    #include <shadowmap_pars_vertex>
    #include <logdepthbuf_pars_vertex>
    #include <clipping_planes_pars_vertex>

    void main() {

      vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );

      #include <uv_vertex>
      #include <uv2_vertex>
      #include <color_vertex>

      // # include <beginnormal_vertex>
      // Compute normal from heightmap
      vec3 objectNormal = vec3(
        ( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
        ( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
        1.0 );
        //<beginnormal_vertex>

        #include <morphnormal_vertex>
        #include <skinbase_vertex>
        #include <skinnormal_vertex>
        #include <defaultnormal_vertex>

        #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

        vNormal = normalize( transformedNormal );

        #endif

        //# include <begin_vertex>
        float heightValue = texture2D( heightmap, uv ).x;
        vec3 transformed = vec3( position.x, position.y, heightValue );
        //<begin_vertex>

        #include <morphtarget_vertex>
        #include <skinning_vertex>
        #include <displacementmap_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
        #include <clipping_planes_vertex>

        vViewPosition = - mvPosition.xyz;

        #include <worldpos_vertex>
        #include <envmap_vertex>
        #include <shadowmap_vertex>

      }

      </script>

      <script>
      var move_point;
      var ValuesChanger;
      //var dataMouseSize;
      var nn;
      //https://stackoverflow.com/questions/831030/how-to-get-get-request-parameters-in-javascript
      function get_url_params(name){
        if(name=(new RegExp('[?&]'+encodeURIComponent(name)+'=([^&]*)')).exec(location.search)) {
          return decodeURIComponent(name[1]);
        }

      }


      if ( WEBGL.isWebGLAvailable() === false ) {

        document.body.appendChild( WEBGL.getWebGLErrorMessage() );

      }

      var hash = document.location.hash.substr( 1 );
      if ( hash ) hash = parseInt( hash, 0 );

      // Texture width for simulation
      var WIDTH = hash || 512;

      // Water size in system units
      var BOUNDS = 512;
      var BOUNDS_HALF = BOUNDS * 0.5;

      var container, stats;
      var camera, scene, renderer;
      var mouseMoved = false;
      var mouseCoords = new THREE.Vector2();
      var raycaster = new THREE.Raycaster();

      var waterMesh;
      var meshRay;
      var gpuCompute;
      var heightmapVariable;
      var waterUniforms;
      var smoothShader;
      var readWaterLevelShader;
      var readWaterLevelRenderTarget;
      var readWaterLevelImage;
      var waterNormal = new THREE.Vector3();

      var NUM_SPHERES = 5;
      var spheres = [];
      var spheresEnabled = false;

      var simplex = new SimplexNoise();

      document.getElementById( 'waterSize' ).innerText = WIDTH*2 + ' x ' + WIDTH;

      function change( n ) {

        location.hash = n;
        location.reload();
        return false;

      }


      var options = '';
      for ( var i = 4; i < 10; i ++ ) {

        var j = Math.pow( 2, i );
        options += '<a href="#" onclick="return change(' + j + ')">' + j + 'x' + j + '</a> ';

      }
      document.getElementById( 'options' ).innerHTML = options;

      init();
      animate();

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        var zoom_margin = 20;
        // Calculate the camera distance https://stackoverflow.com/questions/14614252/how-to-fit-camera-to-object
        var dist = 200;
        var hheight = BOUNDS;
        var wwidth = BOUNDS - zoom_margin;
        //var fov = 2 * Math.atan( hheight / ( 2 * dist ) ) * ( 180 / Math.PI ); //to height
        var fov = 2 * Math.atan( ( wwidth / (window.innerWidth / window.innerHeight) ) / ( 2 * dist ) ) * ( 180 / Math.PI ); // in degrees

        camera = new THREE.PerspectiveCamera( fov, window.innerWidth / window.innerHeight, 1, 3000 );
        camera.position.set( 0, dist, 0 );

        //camera.updateProjectionMatrix();

        scene = new THREE.Scene();

        var sun = new THREE.DirectionalLight( 0x2DFF39, .6 );
        sun.position.set( 300, 400, 175 );
        scene.add( sun );

        var sun2 = new THREE.DirectionalLight( 0xFFFFFF, 1 ); //0xFFF272
        sun2.position.set( - 100, 350, - 200 );
        scene.add( sun2 );

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        var controls = new THREE.OrbitControls( camera, renderer.domElement );

        stats = new Stats();
        container.appendChild( stats.dom ); //STATS TURNED OFF

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        document.addEventListener( 'keydown', function ( event ) {

          // W Pressed: Toggle wireframe
          if ( event.keyCode === 87 ) {

            waterMesh.material.wireframe = ! waterMesh.material.wireframe;
            waterMesh.material.needsUpdate = true;

          }

        }, false );

        window.addEventListener( 'resize', onWindowResize, false );

        //GUI and Adjustments

        var gui = new dat.GUI();

        var effectController = {
          mouseSize: 20.0,
          viscosity: 0.99, //.999 is max
          spheresEnabled: spheresEnabled
        };

        valuesChanger = function (dataMouseSize) {

          dataMouseSize = dataMouseSize || effectController.mouseSize;

          heightmapVariable.material.uniforms[ "mouseSize" ].value = dataMouseSize;
          heightmapVariable.material.uniforms[ "viscosityConstant" ].value = effectController.viscosity;
          spheresEnabled = effectController.spheresEnabled;
          for ( var i = 0; i < NUM_SPHERES; i ++ ) {

            if ( spheres[ i ] ) {

              spheres[ i ].visible = spheresEnabled;

            }

          }

        };

        gui.add( effectController, "mouseSize", 1.0, 100.0, 1.0 ).onChange( valuesChanger );
        gui.add( effectController, "viscosity", 0.9, 0.999, 0.001 ).onChange( valuesChanger );
        gui.add( effectController, "spheresEnabled", 0, 1, 1 ).onChange( valuesChanger );
        var buttonSmooth = {
          smoothWater: function () {

            smoothWater();

          }
        };
        gui.add( buttonSmooth, 'smoothWater' );


        initWater();

        createSpheres();

        valuesChanger();

      }


      function initWater() {



        var geometry = new THREE.PlaneBufferGeometry( BOUNDS, BOUNDS, WIDTH - 1, WIDTH - 1 );

        // material: make a ShaderMaterial clone of MeshPhongMaterial, with customized vertex shader
        var material = new THREE.ShaderMaterial( {
          uniforms: THREE.UniformsUtils.merge( [
            THREE.ShaderLib[ 'phong' ].uniforms,
            {
              "heightmap": { value: null }
            }
          ] ),
          vertexShader: document.getElementById( 'waterVertexShader' ).textContent,
          fragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]

        } );

        material.lights = true;
        var loadingManager = new THREE.LoadingManager( function () {
        } );
        var textureLoader = new THREE.TextureLoader( loadingManager );


        // Material attributes from MeshPhongMaterial, correlates to 'diffuse' in uniforms settings
        material.color = new THREE.Color( 0xEBC4FF);// FFB0C0 );


        //This is where faces could go
        var mapSpecular = textureLoader.load( "textures/skin/Skin_tiled_blue_2048.jpg" );

        //var mapSpecular = textureLoader.load( "models/gltf/LeePerrySmith/Map-SPEC.jpg" );
        mapSpecular.anisotropy = 4;
        mapSpecular.wrapS = mapSpecular.wrapT = THREE.RepeatWrapping;
        mapSpecular.format = THREE.RGBFormat;
        material.specular = new THREE.Color( 0x473C41 );
        material.shininess = 10;
        material.specularMap = mapSpecular;


        //Emissive settings, though intensity doesn't seem to do anything.
        // first two give it a veiny look somehow
        var mapEmissive = textureLoader.load( "textures/skin/Skin_tiled_blue_2048.jpg" );
        material.emissive = new THREE.Color( 0x85702F);//85702F this is the veiny one ); //latest with Caitlin 4286A6
        material.emissiveMap = mapEmissive;



        // Weird skin texture
        //several test DIVERSIONS
        switch(get_url_params("texture")) {
          case "Skin_Map_Light_Blue_3_8_2019.jpg":
          var skin_texture = textureLoader.load( "textures/skin/Skin_Map_Light_Blue_3_8_2019.jpg" );
          break;
          case "Skin_Map_Blue_3_8_2019.jpg":
          var skin_texture = textureLoader.load( "textures/skin/Skin_Map_Blue_3_8_2019.jpg" );
          break;
          case "Skin_skintone_W_Map.jpg":
          var skin_texture = textureLoader.load( "textures/skin/Skin_skintone_W_Map.jpg" );
          break;
          case "Skin_W_Map2.jpg":
          var skin_texture = textureLoader.load( "textures/skin/Skin_W_Map2.jpg" );
          break;
          default:
          var skin_texture = textureLoader.load( "textures/skin/Skin_tiled_blue_2048.jpg" );

        }

        //var skin_texture = textureLoader.load( "textures/skin/Skin_Map_Low_Saturation_3_7_2019.jpg" );

        //var skin_texture = textureLoader.load( "textures/skin/Skin_skintone_W_Map.jpg" );
        //var skin_texture = new THREE.TextureLoader().load( "textures/skin/httpwww.photos-public-domain.com20110929skin_512x512.jpg" );
        material.map = skin_texture;


        //Bump map for skin texture
        var mapHeight = textureLoader.load( "textures/skin/Skin_tiled_blue_2048.jpg" );
        mapHeight.anisotropy = 4;
        mapHeight.wrapS = mapHeight.wrapT = THREE.RepeatWrapping;
        mapHeight.format = THREE.RGBFormat;
        material.bumpMap = mapHeight;

        material.transparent = false;



        // Sets the uniforms with the material values
        material.uniforms[ "diffuse" ].value = material.color;

        material.uniforms[ "shininess" ].value = Math.max( material.shininess, 1e-4 );
        //material.uniforms[ "specular" ].value = material.specular;
        //material.uniforms["specularMap"].value = material.specularMap;


        material.uniforms[ "map" ].value = material.map;

        material.uniforms[ "bumpMap" ].value = material.bumpMap;

        //material.uniforms[ "opacity" ].value = 1;//material.opacity;



        // Defines
        material.defines.WIDTH = WIDTH.toFixed( 1 );
        material.defines.BOUNDS = BOUNDS.toFixed( 1 );

        waterUniforms = material.uniforms;

        waterMesh = new THREE.Mesh( geometry, material );
        waterMesh.rotation.x = - Math.PI / 2;
        waterMesh.matrixAutoUpdate = false;
        waterMesh.updateMatrix();

        scene.add( waterMesh );

        // Mesh just for mouse raycasting
        var geometryRay = new THREE.PlaneBufferGeometry( BOUNDS, BOUNDS, 1, 1 );
        meshRay = new THREE.Mesh( geometryRay, new THREE.MeshBasicMaterial( { color: 0xFFFFFF, visible: false } ) );
        meshRay.rotation.x = - Math.PI / 2;
        meshRay.matrixAutoUpdate = false;
        meshRay.updateMatrix();
        scene.add( meshRay );


        // Creates the gpu computation class and sets it up

        gpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );

        var heightmap0 = gpuCompute.createTexture();

        fillTexture( heightmap0 );

        heightmapVariable = gpuCompute.addVariable( "heightmap", document.getElementById( 'heightmapFragmentShader' ).textContent, heightmap0 );

        gpuCompute.setVariableDependencies( heightmapVariable, [ heightmapVariable ] );

        heightmapVariable.material.uniforms[ "mousePos" ] = { value: new THREE.Vector2( 10000, 10000 ) };
        heightmapVariable.material.uniforms[ "mouseSize" ] = { value: 20.0 };
        heightmapVariable.material.uniforms[ "viscosityConstant" ] = { value: 0.98 };
        heightmapVariable.material.uniforms[ "heightCompensation" ] = { value: 0 };
        heightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed( 1 );

        var error = gpuCompute.init();
        if ( error !== null ) {

          console.error( error );

        }

        // Create compute shader to smooth the water surface and velocity
        smoothShader = gpuCompute.createShaderMaterial( document.getElementById( 'smoothFragmentShader' ).textContent, { texture: { value: null } } );

        // Create compute shader to read water level
        readWaterLevelShader = gpuCompute.createShaderMaterial( document.getElementById( 'readWaterLevelFragmentShader' ).textContent, {
          point1: { value: new THREE.Vector2() },
          texture: { value: null }
        } );
        readWaterLevelShader.defines.WIDTH = WIDTH.toFixed( 1 );
        readWaterLevelShader.defines.BOUNDS = BOUNDS.toFixed( 1 );

        // Create a 4x1 pixel image and a render target (Uint8, 4 channels, 1 byte per channel) to read water height and orientation
        readWaterLevelImage = new Uint8Array( 4 * 1 * 4 );

        readWaterLevelRenderTarget = new THREE.WebGLRenderTarget( 4, 1, {
          wrapS: THREE.ClampToEdgeWrapping,
          wrapT: THREE.ClampToEdgeWrapping,
          minFilter: THREE.NearestFilter,
          magFilter: THREE.NearestFilter,
          format: THREE.RGBAFormat,
          type: THREE.UnsignedByteType,
          stencilBuffer: false,
          depthBuffer: false
        } );

      }

      function fillTexture( texture ) {

        var waterMaxHeight = 10;

        function noise( x, y ) {

          var multR = waterMaxHeight;
          var mult = 0.025;
          var r = 0;
          for ( var i = 0; i < 15; i ++ ) {

            r += multR * simplex.noise( x * mult, y * mult );
            multR *= 0.53 + 0.025 * i;
            mult *= 1.25;

          }
          return r;

        }

        var pixels = texture.image.data;

        var p = 0;
        for ( var j = 0; j < WIDTH; j ++ ) {

          for ( var i = 0; i < WIDTH; i ++ ) {

            var x = i * 128 / WIDTH;
            var y = j * 128 / WIDTH;

            pixels[ p + 0 ] = noise( x, y, 123.4 );
            pixels[ p + 1 ] = pixels[ p + 0 ];
            pixels[ p + 2 ] = 0;
            pixels[ p + 3 ] = 1;

            p += 4;

          }

        }

      }

      function smoothWater() {

        var currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );
        var alternateRenderTarget = gpuCompute.getAlternateRenderTarget( heightmapVariable );

        for ( var i = 0; i < 10; i ++ ) {

          smoothShader.uniforms[ "texture" ].value = currentRenderTarget.texture;
          gpuCompute.doRenderTarget( smoothShader, alternateRenderTarget );

          smoothShader.uniforms[ "texture" ].value = alternateRenderTarget.texture;
          gpuCompute.doRenderTarget( smoothShader, currentRenderTarget );

        }

      }

      function createSpheres() {

        var sphereTemplate = new THREE.Mesh( new THREE.SphereBufferGeometry( 4, 24, 12 ), new THREE.MeshPhongMaterial( { color: 0xFFFF00 } ) );

        for ( var i = 0; i < NUM_SPHERES; i ++ ) {

          var sphere = sphereTemplate;
          if ( i < NUM_SPHERES - 1 ) {

            sphere = sphereTemplate.clone();

          }

          sphere.position.x = ( Math.random() - 0.5 ) * BOUNDS * 0.7;
          sphere.position.z = ( Math.random() - 0.5 ) * BOUNDS * 0.7;

          sphere.userData.velocity = new THREE.Vector3();

          scene.add( sphere );

          spheres[ i ] = sphere;

        }

      }

      function sphereDynamics() {

        var currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );

        readWaterLevelShader.uniforms[ "texture" ].value = currentRenderTarget.texture;
        var gl = renderer.context;

        for ( var i = 0; i < NUM_SPHERES; i ++ ) {

          var sphere = spheres[ i ];

          if ( sphere ) {

            // Read water level and orientation
            var u = 0.5 * sphere.position.x / BOUNDS_HALF + 0.5;
            var v = 1 - ( 0.5 * sphere.position.z / BOUNDS_HALF + 0.5 );
            readWaterLevelShader.uniforms[ "point1" ].value.set( u, v );
            gpuCompute.doRenderTarget( readWaterLevelShader, readWaterLevelRenderTarget );
            gl.readPixels( 0, 0, 4, 1, gl.RGBA, gl.UNSIGNED_BYTE, readWaterLevelImage );
            var pixels = new Float32Array( readWaterLevelImage.buffer );

            // Get orientation
            waterNormal.set( pixels[ 1 ], 0, - pixels[ 2 ] );

            var pos = sphere.position;

            // Set height
            pos.y = pixels[ 0 ];

            // Move sphere
            waterNormal.multiplyScalar( 0.1 );
            sphere.userData.velocity.add( waterNormal );
            sphere.userData.velocity.multiplyScalar( 0.998 );
            pos.add( sphere.userData.velocity );

            if ( pos.x < - BOUNDS_HALF ) {

              pos.x = - BOUNDS_HALF + 0.001;
              sphere.userData.velocity.x *= - 0.3;

            } else if ( pos.x > BOUNDS_HALF ) {

              pos.x = BOUNDS_HALF - 0.001;
              sphere.userData.velocity.x *= - 0.3;

            }

            if ( pos.z < - BOUNDS_HALF ) {

              pos.z = - BOUNDS_HALF + 0.001;
              sphere.userData.velocity.z *= - 0.3;

            } else if ( pos.z > BOUNDS_HALF ) {

              pos.z = BOUNDS_HALF - 0.001;
              sphere.userData.velocity.z *= - 0.3;

            }

          }

        }

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );


      }

      function setMouseCoords( x, y ) {
        mouseCoords.set( ( x / renderer.domElement.clientWidth ) * 2 - 1, - ( y / renderer.domElement.clientHeight ) * 2 + 1 );

        mouseMoved = true;

      }

      function onDocumentMouseMove( event ) {

        setMouseCoords( event.clientX, event.clientY );

      }

      function onDocumentTouchStart( event ) {

        if ( event.touches.length === 1 ) {

          event.preventDefault();

          setMouseCoords( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );


        }

      }

      function onDocumentTouchMove( event ) {

        if ( event.touches.length === 1 ) {

          event.preventDefault();

          setMouseCoords( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );


        }

      }

      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }

      function render() {

        // Set uniforms: mouse interaction
        var uniforms = heightmapVariable.material.uniforms;
        if ( mouseMoved ) {

          raycaster.setFromCamera( mouseCoords, camera );

          var intersects = raycaster.intersectObject( meshRay );

          if ( intersects.length > 0 ) {
            var point = intersects[ 0 ].point;
            //console.log(point.x+" "+point.z)
            uniforms[ "mousePos" ].value.set( point.x, point.z );

          } else {

            uniforms[ "mousePos" ].value.set( 10000, 10000 );

          }

          mouseMoved = false;

        } else {

          //uniforms[ "mousePos" ].value.set( 10000, 10000 );
          //move_point = {x:parseInt(Math.random()*512-256),z:parseInt(Math.random()*512-256)}
          var point = move_point;//intersects[ 0 ].point;
          if (point != undefined) {
            //console.log(point.x+" "+point.z)
            uniforms[ "mousePos" ].value.set( point.x, point.z );
          }


        }

        // Do the gpu computation
        gpuCompute.compute();

        if ( spheresEnabled ) {

          sphereDynamics();

        }

        // Get compute output in custom uniform
        waterUniforms[ "heightmap" ].value = gpuCompute.getCurrentRenderTarget( heightmapVariable ).texture;

        // Render
        renderer.render( scene, camera );

      }

      </script>

      //D3 Map Projection
      <script>

      var width = 960;
      height = 600;
      scaler = 800;
      default_scaler = 1000; //not sure why the heck d3 has default scaling value at 1000?


      var projection = d3.geo.albersUsa()
      .scale([scaler])
      .translate([width/2, height/2]);


      var file = get_url_params("data");
      if (file == undefined)  var file = "data/uscitiesv1.4.csv";//"data/us_states.csv";

      var the_data;
      var the_data2;


      Papa.parse(file, {
        download: true,
        complete: function(results){
          console.log("Finished:", results.data.length)


          //Filter out noncontiguous US places Hawaii, Pureto Rico, and Alaska because we are showing a less abstract continental map vs just USA, and these places don't really appear in this map
          function checker(value) {
            var filtered_states =  [", AK", " AK", ", PR", " PR", ", HI", " HI"]; //only commas 202 are removed. if non comma filters are included, 549 are removed. Out of the 347 extra, how many are false positives? adding the slice(-4) to check only the ending part of site desciption for state abbreviation I get 327 filtered out, so 222 false positives restored by using slice
            for (var i = 0; i < filtered_states.length; i++) {
              if (value[1] == undefined) return false;
              if (value[1].slice(-4).indexOf(filtered_states[i]) > -1) {
                //if (value[1].indexOf(filtered_states[i]) < )
                return false;
              }
            }
            return true;
          }
          the_data = {"data": results.data.filter(checker)};

          var streamflow_column;
          var streamflow_column_name;

          streamflow_column_name = get_url_params("streamflow_column_name");

          //if streaflow column name argument is allowed, find it's index and use it
          if (["percentile", "class", "stage", "flow", "percent_median", "percent_mean"].includes(streamflow_column_name)) {
            streamflow_column = the_data.data[0].indexOf(streamflow_column_name);
          } else {
            //default values if nothing is provided in the url parameters
            streamflow_column = 13;
            streamflow_column_name = "percentile";
          }

          var column_data_max = 0.0; //if using something other than percentile (which is already 0-100), we need to figure out comparative percentage of stage so need stage max
          var column_data_min = 0.0;
          for (var i=1; i<the_data.data.length; i++) {
            column_data_max = parseFloat(the_data.data[i][streamflow_column]) > column_data_max ? the_data.data[i][streamflow_column] : column_data_max;

            column_data_min = parseFloat(the_data.data[i][streamflow_column]) < column_data_min ? the_data.data[i][streamflow_column] : column_data_min;
          }





          //Logarithmic scaling
          var logsl = new LogSlider({minval: column_data_min, maxval: column_data_max});


        }
      });

      function convertRange( value, r1, r2 ) {
        return ( value - r1[ 0 ] ) * ( r2[ 1 ] - r2[ 0 ] ) / ( r1[ 1 ] - r1[ 0 ] ) + r2[ 0 ];
      }




      </script>
    </body>
    </html>
